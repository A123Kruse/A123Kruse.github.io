<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI or Real? ‚Äî Game</title>

    <!-- Your styles -->
    <link rel="stylesheet" href="styles/site.css">
    <link rel="stylesheet" href="styles/streak.css">
</head>
<body>
    <div class="app">
        <header>
            <a class="link" href="index.html">‚Üê Home</a>
            <div class="title">AI or Real? ‚Äî Game</div>
            <div class="meta" aria-live="polite">
                <span class="pill" id="scorePill">Score: 0</span>
                <span class="pill" id="roundPill">Round: ‚Äì</span>
                <span class="pill" id="catPill" style="display:none"></span>
            </div>
        </header>

        <div class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
            <div id="progress"></div>
        </div>
        <p class="small">Pick the image that was generated by AI. Keys: <b>A</b>/<b>B</b> select, <b>R</b> reveal, <b>N</b> next.</p>

        <main class="board">
            <div id="status" class="small"></div>
            <div id="cards" class="cards"></div>

            <div class="controls">
                <button id="revealBtn" class="btn-main" disabled>Reveal</button>
                <div class="small" id="categoryNote"></div>
                <div>
                    <button id="nextBtn" class="btn-main" disabled>Next</button>
                    <button id="restartBtn" class="btn-main" style="display:none">Restart</button>
                </div>
            </div>

            <div id="error" class="error"></div>
            <p class="sr-only" id="ariaLive"></p>
        </main>

        <!-- Streak popup (toast + confetti) -->
        <div id="streakPop" class="streak-pop" aria-live="polite" aria-atomic="true" hidden>
            <div class="toast">üî• Streak √ó<span id="streakCount">3</span> ‚Äî amazing! üéâ</div>
            <div class="confetti" aria-hidden="true"></div>
        </div>

        <!-- Guard: toast + Next mapping + error logger (kept BEFORE main script) -->
        <script>
            console.log('[guard] v3');

            // Safe fallback so __toast never throws during debugging
            window.__toast = (n = 3) => {
                const pop = document.getElementById('streakPop');
                const conf = pop?.querySelector('.confetti');
                const count = document.getElementById('streakCount');
                if (!pop || !conf) return console.warn('[toast] popup not found');
                if (count) count.textContent = String(n);
                conf.innerHTML = '';
                for (let i = 0; i < 36; i++) {
                    const piece = document.createElement('i');
                    piece.style.setProperty('--x', (5 + Math.random() * 90).toFixed(2));
                    piece.style.setProperty('--t', String(900 + Math.random() * 700));
                    piece.style.setProperty('--d', String(Math.random() * 350));
                    conf.appendChild(piece);
                }
                pop.hidden = true; pop.hidden = false; void pop.offsetWidth;
                pop.classList.add('show');
                setTimeout(() => { pop.classList.remove('show'); setTimeout(() => { pop.hidden = true; conf.innerHTML = ''; }, 220); }, 1400);
            };

            // Keep Next button in lockstep with the N shortcut
            window.addEventListener('DOMContentLoaded', () => {
                const next = document.getElementById('nextBtn');
                if (next) next.addEventListener('click', () =>
                    window.dispatchEvent(new KeyboardEvent('keydown', { key: 'n' }))
                );
            });

            // Show exact boot errors on screen and console
            window.addEventListener('error', (e) => {
                const box = document.getElementById('error');
                if (box) box.textContent = `${e.message} @ ${e.filename?.split('/').pop()}:${e.lineno}`;
                console.error('[boot error]', e.error || e.message, e);
            });
        </script>

        <!-- Main game script -->
        <script>
            (function () {
                console.log('[game] inline script started');

                /* ---------- Elements & state ---------- */
                const $ = (s, r = document) => r.querySelector(s);
                const el = {
                    cards: $('#cards'),
                    progress: $('#progress'),
                    score: $('#scorePill'),
                    round: $('#roundPill'),
                    reveal: $('#revealBtn'),
                    next: $('#nextBtn'),
                    restart: $('#restartBtn'),
                    status: $('#status'),
                    error: $('#error'),
                    aria: $('#ariaLive'),
                    streakPop: $('#streakPop'),
                    streakCount: $('#streakCount'),
                    catNote: $('#categoryNote'),
                    catPill: $('#catPill'),
                };

                const state = {
                    rounds: [],
                    i: 0,
                    score: 0,
                    picked: null,
                    aiStreak: 0,
                    bestStreak: 0,
                    breakdown: {},
                    shuffleSides: true,
                };

                const params = new URLSearchParams(location.search);
                const startCat = params.get('cat');
                state.shuffleSides = params.get('shuffle') !== 'false';

                /* ---------- Helpers ---------- */
                const enc = (s) => encodeURIComponent(String(s || '').trim());
                const imgSrc = (label, cat, entry) => {
                    const file = typeof entry === 'string' ? entry : (entry?.file ?? entry?.src ?? '');
                    if (!file) return '';
                    const base = label === 'ai' ? 'images/ai' : 'images/real';
                    return `${base}/${enc(cat)}/${enc(file)}`;
                };
                const shuffle = (a) => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; };
                const current = () => state.rounds[state.i];

                function updateMeta() {
                    el.score.textContent = `Score: ${state.score}`;
                    el.round.textContent = `Round: ${Math.min(state.i + 1, state.rounds.length)} / ${state.rounds.length || '‚Äì'}`;
                    const pct = state.rounds.length ? Math.round((state.i) / state.rounds.length * 100) : 0;
                    el.progress.style.width = pct + '%';
                    el.progress.parentElement.setAttribute('aria-valuenow', String(pct));
                }

                /* ---------- Build & load rounds (defensive against manifest shape) ---------- */
                async function start() {
                    try {
                        const res = await fetch('images/manifest.json', { cache: 'no-store' });
                        if (!res.ok) throw new Error(`Failed to load manifest (HTTP ${res.status})`);
                        const manifest = await res.json();

                        // Limit to a selected category (case/space insensitive) if ?cat= is present
                        let m = manifest;
                        if (startCat) {
                            const keys = Object.keys(manifest || {});
                            const norm = s => String(s).toLowerCase().replace(/[\s_-]+/g, '');
                            const hit = keys.find(k => norm(k) === norm(startCat));
                            if (hit) {
                                m = { [hit]: manifest[hit] };
                                if (el.catPill) { el.catPill.textContent = `Category: ${hit}`; el.catPill.style.display = 'inline-block'; }
                            } else if (el.catPill) {
                                el.catPill.style.display = 'none';
                            }
                        } else if (el.catPill) {
                            el.catPill.style.display = 'none';
                        }

                        const rounds = [];
                        const skipped = [];

                        for (const cat of Object.keys(m || {})) {
                            const real = Array.isArray(m[cat]?.real) ? m[cat].real : [];
                            const ai = Array.isArray(m[cat]?.ai) ? m[cat].ai : [];
                            const n = Math.min(real.length, ai.length);
                            if (!n) { skipped.push([cat, 'no pairs']); continue; }

                            for (let i = 0; i < n; i++) {
                                const rSrc = imgSrc('real', cat, real[i]);
                                const aSrc = imgSrc('ai', cat, ai[i]);
                                if (!rSrc || !aSrc) { skipped.push([cat, `bad file @ index ${i}`]); continue; }
                                rounds.push({
                                    category: cat,
                                    images: [
                                        { src: rSrc, label: 'real', alt: (typeof real[i] === 'string' ? real[i] : (real[i]?.alt || '')) },
                                        { src: aSrc, label: 'ai', alt: (typeof ai[i] === 'string' ? ai[i] : (ai[i]?.alt || '')) },
                                    ],
                                });
                            }
                        }

                        if (!rounds.length) {
                            const why = skipped.length ? ` Skipped: ${skipped.map(([c, w]) => `${c} (${w})`).join(', ')}` : '';
                            throw new Error('No playable rounds.' + why);
                        }

                        shuffle(rounds);
                        state.rounds = rounds;
                        state.i = 0; state.score = 0; state.picked = null;
                        state.aiStreak = 0; state.bestStreak = 0; state.breakdown = {};
                        render();
                        if (skipped.length) console.warn('[manifest] skipped items:', skipped);
                    } catch (e) {
                        el.error.textContent = e.message || 'Failed to build rounds.';
                        console.error('[start error]', e);
                    }
                }

                /* ---------- Rendering & interactions ---------- */
                function render() {
                    const r = current();
                    el.cards.innerHTML = '';
                    el.status.textContent = r ? `Round ${state.i + 1}` : '';
                    el.catNote.textContent = r ? `Category: ${r.category}` : '';
                    el.reveal.disabled = !r;
                    el.next.disabled = true;
                    el.restart.style.display = r ? 'none' : 'inline-block';

                    if (!r) return updateMeta();

                    let order = [0, 1];
                    if (state.shuffleSides) order = shuffle(order);

                    order.forEach((srcIdx, visIdx) => {
                        const img = r.images[srcIdx];
                        const card = document.createElement('button');
                        card.className = 'card';
                        card.type = 'button';
                        card.dataset.visualIndex = String(visIdx);
                        card.dataset.srcIndex = String(srcIdx);

                        card.innerHTML = `
                      <div class="label">${visIdx === 0 ? 'A' : 'B'}</div>
                      <div class="frame"><img src="${img.src}" alt="${img.alt || ''}"></div>
                      <div class="pick"><button type="button" class="btn">This is AI</button></div>
                      <div class="reveal"><span class="chip">${img.label.toUpperCase()}</span></div>
                    `;

                        card.addEventListener('click', () => choose(visIdx));
                        card.querySelector('.btn')?.addEventListener('click', (e) => { e.stopPropagation(); choose(visIdx); });
                        el.cards.appendChild(card);
                    });

                    window.onkeydown = (e) => {
                        const k = e.key.toLowerCase();
                        if (k === 'a') choose(0);
                        if (k === 'b') choose(1);
                        if (k === 'r') doReveal();
                        if (k === 'n') doNext();
                    };

                    updateMeta();
                }

                function choose(visIdx) {
                    const r = current(); if (!r) return;
                    el.cards.querySelectorAll('.card').forEach(c => c.style.borderColor = 'var(--ring)');
                    const card = el.cards.querySelector(`.card[data-visual-index="${visIdx}"]`);
                    if (!card) return;
                    state.picked = visIdx;
                    card.style.borderColor = 'var(--accent)';
                    el.status.textContent = `Selected ${visIdx === 0 ? 'A' : 'B'}. Click Reveal or press R.`;
                    el.reveal.disabled = false;
                }

                function doReveal() {
                    const r = current(); if (!r) return;
                    if (state.picked === null || state.picked === undefined) {
                        el.status.textContent = 'Pick A or B first, then click Reveal (or press R).';
                        return;
                    }

                    // Show overlays & mark AI as win color
                    el.cards.querySelectorAll('.reveal').forEach(ov => ov.classList.add('show'));
                    el.cards.querySelectorAll('.card').forEach(card => {
                        const chip = card.querySelector('.reveal .chip');
                        const si = Number(card.dataset.srcIndex);
                        if (chip && r.images[si]?.label === 'ai') chip.classList.add('win');
                    });

                    const selCard = el.cards.querySelector(`.card[data-visual-index="${state.picked}"]`);
                    const srcIndex = selCard && selCard.dataset ? Number(selCard.dataset.srcIndex) : -1;
                    const pickedIsAI = srcIndex >= 0 ? (r.images[srcIndex]?.label === 'ai') : false;

                    if (pickedIsAI) { state.score++; state.aiStreak++; el.status.innerHTML = '<strong>Correct!</strong> You picked the AI image.'; }
                    else { state.aiStreak = 0; el.status.innerHTML = '<strong>Not quite.</strong> The other image is AI.'; }
                    el.score.textContent = `Score: ${state.score}`;

                    // breakdown bookkeeping (safe)
                    const cat = String(r.category || 'all');
                    if (!state.breakdown[cat]) state.breakdown[cat] = { correct: 0, total: 0 };
                    state.breakdown[cat].total += 1;
                    if (pickedIsAI) state.breakdown[cat].correct += 1;

                    if (state.aiStreak > state.bestStreak) state.bestStreak = state.aiStreak;
                    if (state.aiStreak >= 3) fireStreakToast(state.aiStreak);

                    el.next.disabled = false;
                    el.reveal.disabled = true;

                    if (el.aria) el.aria.textContent = pickedIsAI ? 'Correct. You chose the AI image.' : 'Incorrect. The other image was AI.';
                }

                function doNext() {
                    if (!current()) return;
                    if (state.i >= state.rounds.length - 1) return finishGame();
                    state.i++; state.picked = null; render();
                }

                function finishGame() {
                    const total = state.rounds.length || 0;
                    const summary = {
                        score: state.score,
                        total,
                        accuracy: total ? Math.round((state.score / total) * 100) : 0,
                        bestStreak: state.bestStreak,
                        breakdown: state.breakdown,
                        lastCategory: current()?.category || '',
                        ts: Date.now(),
                    };
                    try { sessionStorage.setItem('ai-or-real:summary', JSON.stringify(summary)); } catch { }
                    window.location.href = 'results.html';
                }

                /* ---------- Toast ---------- */
                function fireStreakToast(count) {
                    const pop = el.streakPop;
                    const conf = pop?.querySelector('.confetti');
                    if (!pop || !conf) return;

                    el.streakCount.textContent = String(count);
                    conf.innerHTML = '';
                    for (let i = 0; i < 42; i++) {
                        const piece = document.createElement('i');
                        piece.style.setProperty('--x', (5 + Math.random() * 90).toFixed(2));
                        piece.style.setProperty('--t', String(900 + Math.random() * 700));
                        piece.style.setProperty('--d', String(Math.random() * 350));
                        conf.appendChild(piece);
                    }
                    pop.hidden = true; pop.hidden = false; void pop.offsetWidth;
                    pop.classList.add('show');
                    setTimeout(() => { pop.classList.remove('show'); setTimeout(() => { pop.hidden = true; conf.innerHTML = ''; }, 220); }, 1400);
                }

                // publish the real toast (replaces guard)
                window.__fireStreakToast = fireStreakToast;
                window.__toast = fireStreakToast;

                /* ---------- Wire up & start ---------- */
                el.reveal.addEventListener('click', doReveal);
                el.next.addEventListener('click', doNext);
                el.restart.addEventListener('click', () => { state.i = 0; state.score = 0; state.picked = null; state.aiStreak = 0; state.bestStreak = 0; state.breakdown = {}; render(); });

                start(); // kick off
            })();
        </script>
    </div>
</body>
</html>
